<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>杆菌之刃：孢子求生</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Helvetica Neue', sans-serif, "Microsoft JhengHei";
            overflow: hidden;
        }
        #game-container {
            width: 100%;
            max-width: 1000px;
            aspect-ratio: 16 / 9;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            border: 2px solid rgba(0, 255, 136, 0.7);
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #2c3e50;
        }
        #controls-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(44, 62, 80, 0.7);
            border-radius: 8px;
            text-align: center;
            max-width: 1000px;
            width: 95%;
        }
        h1 {
            margin: 0 0 10px 0;
            color: #00ff88;
            font-size: 1.5em;
        }
        p {
            margin: 2px 0;
            font-size: 0.9em;
        }
        span {
            display: inline-block;
            background: #34495e;
            color: #ecf0f1;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            margin: 0 5px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="controls-info">
        <h1>杆菌之刃：孢子求生</h1>
        <p>
            移動: <span>A</span> / <span>D</span> | 
            跳躍: <span>W</span> |
            下落: <span>S</span> | 
            近戰: <span>J</span> | 
            遠程: <span>K</span> | 
            法術: <span>L</span> | 
            技能: <span>1</span> 回血 <span>2</span> 召喚 <span>3</span> 隱身 <span>4</span> 蠟質
        </p>
    </div>

    <script>
        // 遊戲初始化
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let scale = 1;

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            canvas.width = containerWidth;
            canvas.height = containerHeight;
            
            scale = Math.min(containerWidth / 1200, containerHeight / 675);
            
            if (game) {
                game.width = canvas.width;
                game.height = canvas.height;
                game.scale = scale;
            }
        }
        
        // --- 元件類別定義 ---
        class UI {
            constructor(game) {
                this.game = game;
                this.fontSize = 20;
                this.fontFamily = '"Microsoft JhengHei"';
            }
            draw(context) {
                context.save();
                context.fillStyle = 'white';
                const scaledFontSize = this.fontSize * this.game.scale;
                context.font = `${scaledFontSize}px ${this.fontFamily}`;
                
                // HP
                context.fillText('HP', 20 * this.game.scale, 30 * this.game.scale);
                context.fillStyle = '#c0392b';
                context.fillRect(80 * this.game.scale, 15 * this.game.scale, this.game.player.maxHealth * 2 * this.game.scale, 20 * this.game.scale);
                context.fillStyle = '#e74c3c';
                context.fillRect(80 * this.game.scale, 15 * this.game.scale, this.game.player.health * 2 * this.game.scale, 20 * this.game.scale);
                context.strokeStyle = 'white';
                context.strokeRect(80 * this.game.scale, 15 * this.game.scale, this.game.player.maxHealth * 2 * this.game.scale, 20 * this.game.scale);
                
                // Mana
                context.fillStyle = 'white';
                context.fillText('MP', 20 * this.game.scale, 60 * this.game.scale);
                context.fillStyle = '#2980b9';
                context.fillRect(80 * this.game.scale, 45 * this.game.scale, this.game.player.maxMana * 2 * this.game.scale, 20 * this.game.scale);
                context.fillStyle = '#3498db';
                context.fillRect(80 * this.game.scale, 45 * this.game.scale, this.game.player.mana * 2 * this.game.scale, 20 * this.game.scale);
                context.strokeStyle = 'white';
                context.strokeRect(80 * this.game.scale, 45 * this.game.scale, this.game.player.maxMana * 2 * this.game.scale, 20 * this.game.scale);

                // Energy
                context.fillStyle = 'white';
                context.fillText('能量', 20 * this.game.scale, 90 * this.game.scale);
                context.fillStyle = '#f39c12';
                context.fillRect(80 * this.game.scale, 75 * this.game.scale, this.game.player.energy * 2 * this.game.scale, 20 * this.game.scale);
                context.strokeStyle = 'white';
                context.strokeRect(80 * this.game.scale, 75 * this.game.scale, this.game.player.maxEnergy * 2 * this.game.scale, 20 * this.game.scale);

                // Level
                context.textAlign = 'right';
                const enemiesLeft = this.game.enemiesToSpawn.length + this.game.enemies.length;
                context.fillText(`敵人剩餘: ${enemiesLeft}`, this.game.width - 20 * this.game.scale, 30 * this.game.scale);
                
                // Status effects
                let statusY = 60 * this.game.scale;
                if(this.game.player.statusEffects.slow.active) {
                    context.fillStyle = 'cyan';
                    context.fillText('低溫', this.game.width - 20 * this.game.scale, statusY);
                    statusY += 30 * this.game.scale;
                }
                if(this.game.player.statusEffects.burn.active) {
                    context.fillStyle = 'orange';
                    context.fillText('高溫', this.game.width - 20 * this.game.scale, statusY);
                    statusY += 30 * this.game.scale;
                }
                if(this.game.player.statusEffects.silence.active) {
                    context.fillStyle = 'gray';
                    context.fillText('抗生素', this.game.width - 20 * this.game.scale, statusY);
                }

                context.restore();
            }
        }

        class Background {
            constructor(game) {
                this.game = game;
                this.level = game.level;
            }
            updateLevel(){
                this.level = this.game.level;
            }
            draw(context) {
                 if (this.level <= 2) {
                    context.fillStyle = '#87CEEB';
                    context.fillRect(0, 0, this.game.worldWidth, this.game.height);
                } else {
                    const depth = Math.min((this.level - 3) * 0.1, 0.5);
                    const baseR = 139, baseG = 69, baseB = 19;
                    const r = baseR * (1 - depth);
                    const g = baseG * (1 - depth);
                    const b = baseB * (1 - depth);
                    context.fillStyle = `rgb(${r},${g},${b})`;
                    context.fillRect(0, 0, this.game.worldWidth, this.game.height);
                    
                    const wallColorDarker = `rgb(${r*0.8},${g*0.8},${b*0.8})`;
                    context.fillStyle = wallColorDarker;
                    const cavernTopHeight = this.game.height * 0.2 * (1 - Math.min((this.level - 3) * 0.2, 0.8));
                    
                    context.beginPath();
                    context.moveTo(0, cavernTopHeight);
                    for (let x = 0; x < this.game.worldWidth; x+=50) {
                        const randomY = cavernTopHeight + Math.sin(x * 0.01) * 20;
                        context.lineTo(x, randomY);
                    }
                    context.lineTo(this.game.worldWidth, 0);
                    context.lineTo(0,0);
                    context.closePath();
                    context.fill();
                }
            }
        }
        
        class Platform {
            constructor(game, x, y, width, height, isTemporary = false, isWax = false) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.isTemporary = isTemporary;
                this.isWax = isWax;
                this.isDamaged = false;
                if(this.isTemporary){
                    this.lifespan = 17500; // 17.5 秒
                }
            }
            update(deltaTime) {
                if(this.isTemporary){
                    this.lifespan -= deltaTime;
                    if(this.lifespan <= 0) this.markedForDeletion = true;
                }
            }
            draw(context){
                context.save();
                if(this.isWax) {
                    context.globalAlpha = Math.max(0, this.lifespan / 17500);
                    context.fillStyle = 'rgba(240, 230, 140, 0.7)';
                } else {
                    context.fillStyle = '#5D4037';
                }

                context.fillRect(this.x, this.y, this.width, this.height);
                 if (this.isDamaged) {
                    const jagAmount = 5;
                    context.strokeStyle = 'rgba(0,0,0,0.5)';
                    context.lineWidth = 2;
                    context.beginPath();
                    context.moveTo(this.x, this.y);
                    for(let i = this.x; i < this.x + this.width; i+= 15) {
                        context.lineTo(i + 15, this.y + (Math.random() - 0.5) * jagAmount);
                    }
                    context.stroke();
                }
                context.restore();
            }
        }

        class WaxPlatform extends Platform {
            constructor(game, player) {
                super(game, player.x, player.y + player.height, player.width, 20, true, true);
                this.owner = player;
                this.extendableTimer = 1500;
                this.minX = this.x;
                this.maxX = this.x + this.width;
                this.maxWidth = 250;
            }
            update(deltaTime) {
                super.update(deltaTime); // 處理生命週期
                if (this.extendableTimer > 0) {
                    this.extendableTimer -= deltaTime;
                    this.minX = Math.min(this.minX, this.owner.x);
                    this.maxX = Math.max(this.maxX, this.owner.x + this.owner.width);
                    
                    if (this.maxX - this.minX < this.maxWidth) {
                        this.x = this.minX;
                        this.width = this.maxX - this.minX;
                    } else {
                        // 達到最大寬度後停止延伸
                        this.extendableTimer = 0;
                    }
                }
            }
        }
        
        class Player {
            constructor(game) {
                this.game = game;
                this.width = 50;
                this.height = 50;
                this.x = 200;
                this.y = this.game.height * 0.9 - this.height;
                this.speedX = 0;
                this.maxSpeed = 7;
                this.vy = 0;
                this.weight = 0.5;
                this.onPlatform = false;
                this.currentPlatform = null;
                
                this.maxHealth = 100;
                this.health = this.maxHealth;
                this.maxMana = 100;
                this.mana = this.maxMana;
                this.maxEnergy = 100;
                this.energy = 0;

                this.direction = 'right';
                this.cooldowns = { sword: 0, bow: 0, magic: 0 };
                this.skillCooldown = { heal: 0, summon: 0, stealth: 0, wax: 0 };
                this.skillCooldownTime = { heal: 15000, summon: 5000, stealth: 5000, wax: 8000 };
                this.invulnerable = false;
                this.invulnerabilityDuration = 1000;
                this.invulnerabilityTimer = 0;

                this.isStealth = false;
                this.stealthDuration = 2000;
                this.stealthTimer = 0;

                this.statusEffects = {
                    slow: { active: false, timer: 0, duration: 3000 },
                    burn: { active: false, timer: 0, duration: 3000, damage: 0.2 },
                    silence: { active: false, timer: 0, duration: 5000 }
                };
            }
            update(keys, deltaTime) {
                this.handleStatusEffects(deltaTime);
                
                for (const cd in this.cooldowns) {
                    if (this.cooldowns[cd] > 0) this.cooldowns[cd] -= deltaTime;
                }
                 for (const skill in this.skillCooldown) {
                    if (this.skillCooldown[skill] > 0) this.skillCooldown[skill] -= deltaTime;
                }

                if (keys.has('j') && this.cooldowns.sword <= 0) this.swordAttack();
                if (keys.has('k') && this.cooldowns.bow <= 0) this.bowAttack();
                if (keys.has('l') && this.cooldowns.magic <= 0) this.magicAttack();

                if (keys.has('1') && this.skillCooldown.heal <= 0) this.useHeal();
                if (keys.has('2') && this.skillCooldown.summon <= 0) this.useSummon();
                if (keys.has('3') && this.skillCooldown.stealth <= 0) this.useStealth();
                if (keys.has('4') && this.skillCooldown.wax <= 0) this.useWax();
                
                this.speedX = 0;
                let currentMaxSpeed = this.maxSpeed;
                if (this.onPlatform && this.currentPlatform.isWax) currentMaxSpeed *= 0.5;
                if (this.statusEffects.slow.active) currentMaxSpeed *= 0.5;

                if (keys.has('a')) {
                    this.speedX = -currentMaxSpeed;
                    this.direction = 'left';
                }
                if (keys.has('d')) {
                    this.speedX = currentMaxSpeed;
                    this.direction = 'right';
                }
                this.x += this.speedX;

                if (this.x < 0) this.x = 0;
                if (this.x > this.game.worldWidth - this.width) {
                    this.x = this.game.worldWidth - this.width;
                }

                if (keys.has('s') && this.onPlatform && this.currentPlatform && this.currentPlatform.y < this.game.height * 0.9) {
                     this.y += 5;
                }

                this.y += this.vy;
                this.vy += this.weight;

                this.onPlatform = false;
                this.currentPlatform = null;
                this.game.platforms.forEach(platform => {
                    const isDropping = keys.has('s');
                    
                    if (this.vy > 0 && 
                        (!isDropping || platform.y >= this.game.height * 0.9) && 
                        this.x + this.width > platform.x &&
                        this.x < platform.x + platform.width &&
                        this.y + this.height >= platform.y &&
                        this.y + this.height - this.vy < platform.y + 5
                    ) {
                        this.y = platform.y - this.height;
                        this.vy = 0;
                        this.onPlatform = true;
                        this.currentPlatform = platform;
                    } 
                    else if (this.vy < 0 && 
                        this.x + this.width > platform.x &&
                        this.x < platform.x + platform.width &&
                        this.y >= platform.y + platform.height &&
                        this.y + this.vy < platform.y + platform.height
                    ) {
                         this.vy = 0;
                         this.y = platform.y + platform.height;
                    }
                });
                
                if (keys.has('w') && this.onPlatform) {
                    this.vy = -18; 
                }
                
                if (this.invulnerabilityTimer > 0) this.invulnerabilityTimer -= deltaTime;
                else this.invulnerable = false;
                
                if (this.stealthTimer > 0) this.stealthTimer -= deltaTime;
                else this.isStealth = false;

                if (this.mana < this.maxMana) this.mana += 0.1;
            }
            draw(context) {
                context.save();
                if (this.invulnerable && Math.floor(this.invulnerabilityTimer / 100) % 2 === 0) { context.globalAlpha = 0.5; }
                if (this.statusEffects.slow.active || (this.onPlatform && this.currentPlatform.isWax)) {
                    context.fillStyle = 'rgba(240, 230, 140, 0.4)';
                    context.beginPath();
                    context.arc(this.x + this.width/2, this.y + this.height/2, this.width, 0, Math.PI * 2);
                    context.fill();
                }
                if(this.isStealth) {
                    context.globalAlpha = 0.6;
                    context.fillStyle = '#8a9a5b';
                    context.beginPath();
                    context.ellipse(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, this.height / 2.5, 0, 0, Math.PI * 2);
                    context.fill();
                    context.strokeStyle = '#c3d37a';
                    context.stroke();
                } else {
                    context.fillStyle = '#00ff88';
                    context.fillRect(this.x, this.y, this.width, this.height);
                    context.strokeStyle = 'white';
                    context.strokeRect(this.x, this.y, this.width, this.height);
                    if (this.cooldowns.sword > 200 && this.lastAttack === 'sword') {
                        context.fillStyle = 'white';
                        const swordW = 50; const swordH = 10;
                        const swordX = this.direction === 'right' ? this.x + this.width : this.x - swordW;
                        context.fillRect(swordX, this.y + this.height * 0.4, swordW, swordH);
                    }
                }
                context.restore();
            }
            swordAttack() {
                this.cooldowns.sword = 300; this.lastAttack = 'sword';
                const attackWidth = 60; const attackX = this.direction === 'right' ? this.x + this.width : this.x - attackWidth;
                const attackY = this.y; const attackHeight = this.height;
                this.game.enemies.forEach(enemy => {
                    if (this.game.isColliding({ x: attackX, y: attackY, width: attackWidth, height: attackHeight }, enemy)) {
                        enemy.takeDamage(15, 'melee');
                        this.game.floatingMessages.push(new FloatingMessage(this.game, enemy.x, enemy.y, '15', 'white'));
                        this.game.createHitParticles(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                        if (this.energy < this.maxEnergy) this.energy += 2; if(this.energy > this.maxEnergy) this.energy = this.maxEnergy;
                    }
                });
            }
            bowAttack() {
                if(this.mana >= 10) {
                    this.mana -= 10; 
                    this.cooldowns.bow = 100;
                    this.lastAttack = 'bow';
                    const projectileX = this.direction === 'right' ? this.x + this.width : this.x;
                    this.game.projectiles.push(new Projectile(this.game, projectileX, this.y + this.height/2, 10, 'player', this.direction, null, 10, 'bow'));
                }
            }
            magicAttack() {
                if(this.mana >= 30) {
                    this.mana -= 30; 
                    this.cooldowns.magic = 1200; 
                    this.lastAttack = 'magic';
                    for(let i = 0; i < 8; i++){
                        this.game.projectiles.push(new Projectile(this.game, this.x + this.width/2, this.y + this.height/2, 20, 'player', null, (Math.PI * 2 / 8) * i, 5, 'magic'));
                    }
                }
            }
            useHeal() {
                if(this.energy >= 50 && this.skillCooldown.heal <= 0) {
                    this.energy -= 50; 
                    this.skillCooldown.heal = this.skillCooldownTime.heal; 
                    const totalHeal = this.maxHealth * 0.2;
                    const healPerTick = totalHeal / 5;
                    let ticks = 0;
                    const healInterval = setInterval(() => {
                        this.heal(healPerTick);
                        this.game.floatingMessages.push(new FloatingMessage(this.game, this.x, this.y - 10, `+${Math.round(healPerTick)}`, '#2ecc71'));
                        ticks++;
                        if(ticks >= 5 || this.game.gameOver) clearInterval(healInterval);
                    }, 800);
                }
            }
            heal(amount) { this.health += amount; if (this.health > this.maxHealth) this.health = this.maxHealth; }
            useSummon() {
                if(this.energy >= 70 && !this.statusEffects.silence.active && this.game.companions.length < 2) {
                    this.energy -= 70; this.skillCooldown.summon = this.skillCooldownTime.summon;
                    this.game.companions.push(new Companion(this.game, this.x, this.y));
                }
            }
            useStealth() {
                if(this.energy >= 40) {
                    this.energy -= 40; this.skillCooldown.stealth = this.skillCooldownTime.stealth;
                    this.isStealth = true; this.stealthTimer = this.stealthDuration;
                }
            }
             useWax() {
                if(this.energy >= 30 && this.onPlatform && this.skillCooldown.wax <= 0) {
                    this.energy -= 30;
                    this.skillCooldown.wax = this.skillCooldownTime.wax;
                    const wax = new WaxPlatform(this.game, this);
                    this.game.platforms.push(wax);
                }
            }
            takeDamage(damage) {
                if (this.invulnerable || this.isStealth) return;
                this.health -= damage; this.invulnerable = true; this.invulnerabilityTimer = this.invulnerabilityDuration;
                if (this.health <= 0) { this.health = 0; this.game.gameOver = true; }
                this.game.floatingMessages.push(new FloatingMessage(this.game, this.x, this.y, `-${damage}`, '#e74c3c'));
            }
            applyStatusEffect(type) { this.statusEffects[type].active = true; this.statusEffects[type].timer = this.statusEffects[type].duration; }
            handleStatusEffects(deltaTime) {
                for (const effect in this.statusEffects) {
                    if (this.statusEffects[effect].active) {
                        this.statusEffects[effect].timer -= deltaTime;
                        if (this.statusEffects[effect].timer <= 0) this.statusEffects[effect].active = false;
                        if (effect === 'burn' && Math.floor(this.statusEffects[effect].timer % 1000) < 20) {
                             if (this.invulnerable || this.isStealth) return;
                             this.health -= this.statusEffects.burn.damage;
                             this.game.floatingMessages.push(new FloatingMessage(this.game, this.x, this.y, `-${this.statusEffects.burn.damage}`, 'orange'));
                        }
                    }
                }
            }
        }
        
        class Projectile {
            constructor(game, x, y, damage, owner, direction = 'right', angle = null, speed = 10, type = 'generic') {
                this.game = game;
                this.width = 10;
                this.height = 10;
                this.x = x;
                this.y = y;
                this.damage = damage;
                this.owner = owner; 
                this.speed = speed;
                this.attackType = type;
                this.markedForDeletion = false;

                if(angle !== null) {
                    this.vx = Math.cos(angle) * this.speed;
                    this.vy = Math.sin(angle) * this.speed;
                } else {
                    this.vx = direction === 'right' ? this.speed : -this.speed;
                    this.vy = 0;
                }
            }
            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                if (this.x > this.game.worldWidth + this.width || this.x < -this.width) this.markedForDeletion = true;
            }
            draw(context) { context.fillStyle = this.owner === 'player' ? 'cyan' : '#f1c40f'; context.fillRect(this.x, this.y, this.width, this.height); }
        }
        
        class Companion {
            constructor(game, x, y) {
                this.game = game;
                this.width = 25;
                this.height = 25;
                this.x = x;
                this.y = y;
                this.speed = 3;
                this.damage = 5;
                this.lifespan = 5000;
                this.attackCooldown = 500; 
                this.markedForDeletion = false;
            }
            update(deltaTime) {
                this.lifespan -= deltaTime; 
                if(this.lifespan <= 0) this.markedForDeletion = true;
                if (this.y > this.game.height * 2) this.markedForDeletion = true;

                this.attackCooldown -= deltaTime;
                if (this.attackCooldown <= 0) {
                    this.attackCooldown = 500;
                    const magicDamage = 20;
                    const companionDamage = magicDamage * 0.8;
                    for(let i = 0; i < 8; i++){
                        const angle = (Math.PI * 2 / 8) * i;
                        this.game.projectiles.push(new Projectile(this.game, this.x + this.width/2, this.y + this.height/2, companionDamage, 'player', null, angle, 5, 'magic'));
                    }
                }
                
                let closestEnemy = null; let minDistance = Infinity;
                this.game.enemies.forEach(enemy => {
                    const distance = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                    if (distance < minDistance) { minDistance = distance; closestEnemy = enemy; }
                });
                if (closestEnemy) {
                    const angle = Math.atan2(closestEnemy.y + closestEnemy.height/2 - (this.y + this.height/2), closestEnemy.x + closestEnemy.width/2 - (this.x + this.width/2));
                    this.x += Math.cos(angle) * this.speed; this.y += Math.sin(angle) * this.speed;
                } else { this.x += this.speed; }
            }
            draw(context) { context.save(); context.fillStyle = 'lightgreen'; context.globalAlpha = this.lifespan / 5000; context.fillRect(this.x, this.y, this.width, this.height); context.restore(); }
        }

        class Enemy {
             constructor(game, x, y, width, height, health, damage, platform) {
                this.game = game;
                this.width = width;
                this.height = height;
                this.x = x;
                this.y = y;
                this.platform = platform;
                this.maxHealth = health;
                this.health = this.maxHealth;
                this.damage = damage; 
                this.speedX = 0;
                this.baseSpeed = 1;
                this.markedForDeletion = false;
             }
             update(deltaTime) {
                if (this.y > this.game.height * 2) {
                    this.markedForDeletion = true;
                    return;
                }

                let currentSpeed = this.baseSpeed;
                this.game.platforms.forEach(p => {
                    if (p.isWax && this.game.isColliding(this, p)) {
                        currentSpeed *= 0.5;
                    }
                });
                
                const player = this.game.player;
                const dx = player.x - this.x;
                if (dx > 0) {
                    this.speedX = currentSpeed;
                } else if (dx < 0) {
                    this.speedX = -currentSpeed;
                } else {
                    this.speedX = 0;
                }
                this.x += this.speedX;

                if(this.platform) {
                    if(this.x <= this.platform.x) {
                        this.x = this.platform.x;
                    }
                    if(this.x + this.width >= this.platform.x + this.platform.width) {
                        this.x = this.platform.x + this.platform.width - this.width;
                    }
                }
             }
             draw(context) {
                context.fillStyle = this.color || 'red'; context.fillRect(this.x, this.y, this.width, this.height);
                this.drawHealthBar(context);
             }
             drawHealthBar(context) {
                if(this.health < this.maxHealth){
                    const healthBarY = this.y - 10;
                    context.fillStyle = 'darkred'; context.fillRect(this.x, healthBarY, this.width, 5);
                    context.fillStyle = 'red'; context.fillRect(this.x, healthBarY, this.width * (this.health / this.maxHealth), 5);
                }
             }
             takeDamage(damage, type = 'generic') {
                this.health -= damage;
                if (this.health <= 0) {
                    this.markedForDeletion = true;
                    if(this.game.player.energy < this.game.player.maxEnergy) this.game.player.energy += 15; if(this.game.player.energy > this.game.player.maxEnergy) this.game.player.energy = this.game.player.maxEnergy;
                    this.game.createHitParticles(this.x + this.width / 2, this.y + this.height / 2, 'red');
                    if(Math.random() < 0.3) { this.game.items.push(new Glu(this.game, this.x + this.width / 2, this.y + this.height / 2)); }
                }
             }
        }
        
        class Yeast extends Enemy {
            constructor(game, x, y, platform) {
                super(game, x, y, 60, 60, 50, 10, platform);
                this.color = '#ff69b4';
                this.attackCooldown = Math.random() * 1500;
                this.atEdge = false;
                this.edgeTimer = 0;
            }
            update(deltaTime) {
                if (this.y > this.game.height * 2) {
                    this.markedForDeletion = true;
                    return;
                }
                
                if (this.game.level === 1) {
                    super.update(deltaTime);
                    const playerOnScreen = Math.abs(this.game.player.x - this.x) < this.game.width / this.game.scale;
                    if(playerOnScreen && this.attackCooldown <= 0) {
                        this.attackCooldown = 3000 + Math.random() * 2000;
                        const direction = (this.game.player.x < this.x) ? 'left' : 'right';
                        this.game.projectiles.push(new Projectile(this.game, this.x, this.y + this.height / 2, 5, 'enemy', direction));
                    }
                } else {
                    const nextX = this.x + this.speedX;
                    const atLeftEdge = this.platform && nextX <= this.platform.x;
                    const atRightEdge = this.platform && nextX + this.width >= this.platform.x + this.platform.width;

                    if (this.platform && (atLeftEdge || atRightEdge)) {
                        this.atEdge = true;
                    } else {
                        this.atEdge = false;
                        this.edgeTimer = 0;
                        super.update(deltaTime); 
                    }

                    if (this.atEdge) {
                        this.edgeTimer += deltaTime;
                        if (this.edgeTimer > 3000) {
                            if(this.attackCooldown <= 0) {
                                this.attackCooldown = 2000;
                                const player = this.game.player;
                                const angle = Math.atan2((player.y + player.height/2) - (this.y + this.height/2), (player.x + player.width/2) - (this.x + this.width/2));
                                this.game.projectiles.push(new Projectile(this.game, this.x + this.width / 2, this.y + this.height/2, 8, 'enemy', null, angle, 4));
                            }
                        }
                    }
                }
                
                if(this.attackCooldown > 0) this.attackCooldown -= deltaTime;
            }
            draw(context){
                context.fillStyle = this.color; context.beginPath(); context.arc(this.x + this.width / 2, this.y + this.height/2, this.width/2, 0, Math.PI * 2); context.fill();
                this.drawHealthBar(context);
            }
        }
        
        class Anthrax extends Enemy {
             constructor(game, x, y, platform) {
                super(game, x, y, 80, 40, 100, 20, platform);
                this.color = '#800080';
                this.shockwaveCooldown = 5000;
                this.isCharging = false;
                this.chargeTimer = 0;
                this.chargeDuration = 3000;
             }
             update(deltaTime) {
                if (this.y > this.game.height * 2) {
                    this.markedForDeletion = true;
                    return;
                }
                if (this.isCharging) {
                    this.chargeTimer -= deltaTime;
                    this.speedX = 0;
                    if(this.chargeTimer <= 0) {
                        this.detonate();
                    }
                } else {
                    super.update(deltaTime);
                    if (this.shockwaveCooldown > 0) {
                         this.shockwaveCooldown -= deltaTime;
                    }
                    if (this.shockwaveCooldown <= 0 && this.game.player.currentPlatform === this.platform) {
                        this.isCharging = true;
                        this.chargeTimer = this.chargeDuration;
                    }
                }
             }
             detonate() {
                 this.isCharging = false;
                 this.shockwaveCooldown = 5000;
                 this.game.camera.shakeDuration = 500;
                 this.game.camera.shakeMagnitude = 10;

                 if (this.platform) {
                    this.platform.isDamaged = true;
                 }

                 const player = this.game.player;
                 if (player.currentPlatform === this.platform) {
                     player.takeDamage(30);
                 }
             }
             draw(context) {
                let drawColor = this.color;
                if (this.isCharging) {
                    const ratio = 1 - (this.chargeTimer / this.chargeDuration);
                    const flashSpeed = 10 + ratio * 40; 
                    const flash = Math.floor(Date.now() / (1000 / flashSpeed)) % 2 === 0;
                    if (flash) {
                        drawColor = '#ff0000';
                    }
                }
                
                context.fillStyle = drawColor;
                context.fillRect(this.x, this.y, this.width, this.height);
                context.strokeStyle = 'rgba(255, 255, 255, 0.5)'; context.lineWidth = 3; context.strokeRect(this.x - 3, this.y - 3, this.width + 6, this.height + 6);

                context.fillStyle = 'white';
                for(let i = 0; i < 5; i++) {
                    const spikeX = this.x + (i * this.width / 4);
                    const spikeY = this.y - 5;
                    context.beginPath();
                    context.moveTo(spikeX - 4, this.y);
                    context.lineTo(spikeX, spikeY);
                    context.lineTo(spikeX + 4, this.y);
                    context.closePath();
                    context.fill();
                }
                
                this.drawHealthBar(context);
             }
             takeDamage(damage, type = 'generic') {
                 if (type === 'bow' || type === 'magic' || type === 'collision') {
                     this.game.floatingMessages.push(new FloatingMessage(this.game, this.x + this.width / 2, this.y, 'MISS', '#ffff00'));
                     return; 
                 }
                 super.takeDamage(damage, type);
             }
        }

        class Phytophthora extends Enemy {
            constructor(game) {
                super(game, game.worldWidth - 300, game.height * 0.9 - 100, 200, 100, 400, 0);
                this.color = '#8b4513';
                this.x = this.game.worldWidth - this.width - 50;
                this.y = this.game.height * 0.9 - this.height;
                this.speedX = 0;
                this.spawnCooldown = 0;
            }
            update(deltaTime) {
                if(this.spawnCooldown > 0) this.spawnCooldown -= deltaTime;
                else {
                    this.spawnCooldown = 4000;
                    const zoospore = new Projectile(this.game, this.x + this.width / 2, this.y, 10, 'enemy', 'left', null, 2);
                    zoospore.update = function(dt) { const player = this.game.player; const angle = Math.atan2(player.y - this.y, player.x - this.x); this.x += Math.cos(angle) * this.speed; this.y += Math.sin(angle) * this.speed; if (this.x < -this.width || this.x > this.game.worldWidth + this.width) this.markedForDeletion = true; };
                    this.game.projectiles.push(zoospore);
                }
            }
            draw(context) {
                context.fillStyle = this.color; context.beginPath(); context.moveTo(this.x, this.y + this.height); context.quadraticCurveTo(this.x + this.width / 2, this.y - this.height / 2, this.x + this.width, this.y + this.height); context.closePath(); context.fill();
                this.drawHealthBar(context);
            }
        }
        
        class MegaBoss extends Enemy {
            constructor(game) {
                super(game, game.worldWidth - 300, game.height * 0.9 - 200, 250, 200, 1500, 25, game.platforms[0]);
                this.color = '#581845';
                this.baseSpeed = 0.2;
                this.x = this.game.worldWidth - this.width - 50;
                this.y = this.game.height * 0.9 - this.height;
                this.phase = 1;
                this.attackPatternTimer = 8000;
                this.isWarning = false;
                this.warningType = null;
                this.warningTimer = 0;
                this.warningDuration = 5000;
            }
            update(deltaTime) {
                 if(this.isWarning) {
                    this.warningTimer -= deltaTime;
                    if(this.warningTimer <= 0) {
                        this.isWarning = false;
                        if (this.warningType === 'shockwave') this.fireShockwave();
                        if (this.warningType === 'missiles') this.fireAllRangeMissiles();
                    }
                } else {
                    this.attackPatternTimer -= deltaTime;
                    if(this.attackPatternTimer <= 0) {
                        this.executeAttackPattern();
                    }
                    super.update(deltaTime);
                }

                if(this.health < this.maxHealth / 2 && this.phase === 1) { this.phase = 2; this.game.floatingMessages.push(new FloatingMessage(this.game, this.x, this.y, "狂暴!", 'red')); }
            }
            executeAttackPattern() {
                this.attackPatternTimer = (this.phase === 1 ? 8000 : 6000) + Math.random() * 2000; 
                const choice = Math.random();
                if (choice < 0.5) {
                    this.isWarning = true;
                    this.warningType = 'shockwave';
                    this.warningTimer = this.warningDuration;
                } else {
                    this.isWarning = true;
                    this.warningType = 'missiles';
                    this.warningTimer = this.warningDuration;
                }
            }
            fireShockwave() {
                for(let i = 0; i < 36; i++) {
                    const angle = (Math.PI * 2 / 36) * i;
                    this.game.effects.push(new ShockwaveParticle(this.game, this.x + this.width / 2, this.y + this.height / 2, angle));
                }
            }
            fireAllRangeMissiles() {
                const missileCount = this.phase === 2 ? 24 : 12;
                for(let i = 0; i < missileCount; i++){
                    const angle = (Math.PI * 2 / missileCount) * i;
                    this.game.projectiles.push(new Projectile(this.game, this.x + this.width/2, this.y + this.height/2, 20, 'enemy', null, angle, 4));
                }
            }
            draw(context) {
                context.fillStyle = this.phase === 2 ? '#C70039' : this.color; context.beginPath(); context.arc(this.x + this.width/2, this.y + this.height/2, this.width/2, 0, Math.PI * 2); context.fill();
                this.drawHealthBar(context);
            }
        }
        
        class Glu {
            constructor(game, x, y) {
                this.game = game;
                this.width = 15;
                this.height = 15;
                this.x = x;
                this.y = y;
                this.vy = -5; 
                this.weight = 0.3;
                this.markedForDeletion = false;
                this.healAmount = 10;
            }
            update(deltaTime) {
                this.y += this.vy;
                this.vy += this.weight;
                if (this.y > this.game.height * 0.9 - this.height) {
                    this.y = this.game.height * 0.9 - this.height;
                    this.vy = 0;
                }
            }
            draw(context) {
                context.save();
                context.fillStyle = '#f1c40f';
                context.beginPath();
                for (let i = 0; i < 6; i++) {
                    context.lineTo(this.x + this.width/2 * Math.cos(Math.PI / 3 * i), this.y + this.height/2 * Math.sin(Math.PI / 3 * i));
                }
                context.closePath();
                context.fill();
                context.restore();
            }
            applyEffect(player) {
                player.heal(this.healAmount);
                this.game.floatingMessages.push(new FloatingMessage(this.game, player.x, player.y, `+${this.healAmount}`, '#f1c40f'));
            }
        }

        class Particle {
            constructor(game, x, y, color) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.size = Math.random() * 5 + 2;
                this.speedX = (Math.random() * 3 - 1.5);
                this.speedY = (Math.random() * 3 - 1.5);
                this.color = color;
                this.lifespan = 100;
                this.markedForDeletion = false;
            }
            update(deltaTime) {
                this.x += this.speedX;
                this.y += this.speedY;
                this.lifespan -= 2;
                if(this.lifespan <= 0) this.markedForDeletion = true;
            }
            draw(context) {
                context.save();
                context.globalAlpha = this.lifespan / 100;
                context.fillStyle = this.color;
                context.beginPath();
                context.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                context.fill();
                context.restore();
            }
        }

        class ShockwaveParticle {
            constructor(game, x, y, angle) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.speed = 6;
                this.vx = Math.cos(angle) * this.speed;
                this.vy = Math.sin(angle) * this.speed;
                this.size = 8;
                this.lifespan = 2000;
                this.markedForDeletion = false;
                this.damage = 30;
                this.type = 'shockwave';
            }

            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;
                this.lifespan -= deltaTime;
                if (this.lifespan <= 0) this.markedForDeletion = true;

                this.game.platforms.forEach(platform => {
                    if (this.x > platform.x && this.x < platform.x + platform.width &&
                        this.y > platform.y && this.y < platform.y + platform.height) {
                        this.markedForDeletion = true;
                        this.game.createHitParticles(this.x, this.y, '#8e44ad');
                    }
                });
            }

            draw(context) {
                context.save();
                context.globalAlpha = this.lifespan / 2000;
                context.fillStyle = 'rgba(200, 0, 255, 0.7)';
                context.beginPath();
                context.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                context.fill();
                context.restore();
            }
        }
        
        class FloatingMessage {
            constructor(game, x, y, message, color) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.message = message;
                this.color = color;
                this.lifespan = 1000;
                this.markedForDeletion = false;
                this.speedY = -1;
                this.fontSize = 20;
            }
            update(deltaTime) {
                this.y += this.speedY;
                this.lifespan -= deltaTime;
                if(this.lifespan <= 0) this.markedForDeletion = true;
            }
            draw(context) {
                context.save();
                context.globalAlpha = this.lifespan / 1000;
                context.fillStyle = this.color;
                context.font = `${this.fontSize}px "Microsoft JhengHei"`;
                context.fillText(this.message, this.x, this.y);
                context.restore();
            }
        }

        // --- 主遊戲類別定義 ---
        class Game {
            constructor(width, height, scale) {
                this.width = width;
                this.height = height;
                this.scale = scale;
                this.worldWidth = 3000;
                
                this.platforms = [];
                this.background = new Background(this);
                this.generatePlatforms();

                this.player = new Player(this);
                this.keys = new Set();
                this.projectiles = [];
                this.companions = [];
                this.enemies = [];
                this.particles = [];
                this.items = [];
                this.effects = [];
                this.floatingMessages = [];
                this.ui = new UI(this);
                
                this.camera = {
                    x: 0,
                    y: 0,
                    deadZoneX: this.width / 3 / this.scale,
                    shakeDuration: 0,
                    shakeMagnitude: 0,
                };
                
                this.level = 1;
                this.gameOver = false;
                this.gameWon = false;
                this.gameState = 'start'; 
                this.introFadeTimer = 0;

                this.levelData = [
                    { enemies: [ { type: 'Yeast', total: 8 } ], maxOnScreen: 3 },
                    { enemies: [ { type: 'Yeast', total: 12 } ], maxOnScreen: 4 },
                    { enemies: [ { type: 'Anthrax', total: 5 } ], maxOnScreen: 2 },
                    { enemies: [ { type: 'Yeast', total: 8 }, { type: 'Anthrax', total: 4 } ], maxOnScreen: 4 },
                    { enemies: [ { type: 'Phytophthora', total: 1 } ], maxOnScreen: 1 },
                    { enemies: [ { type: 'Yeast', total: 6 }, { type: 'Anthrax', total: 4 }, { type: 'Phytophthora', total: 1 } ], maxOnScreen: 5 },
                    { enemies: [ { type: 'MegaBoss', total: 1 } ], maxOnScreen: 1 }
                ];
                this.enemiesToSpawn = [];
                
                this.setupEventListeners();
                this.loadLevel();
                this.setPlayerInitialPosition();
            }

            setupEventListeners() {
                window.addEventListener('keydown', e => {
                    const key = e.key.toLowerCase();
                    if (this.gameState === 'start') {
                         if (key === 'enter') {
                             this.gameState = 'playing';
                             this.introFadeTimer = 1000; 
                             this.setPlayerInitialPosition();
                         }
                         return;
                    }
                    if (this.gameState === 'gameOver' || this.gameWon) {
                        if (key === 'enter') this.restartGame();
                        return;
                    }
                    if (['w', 'a', 'd', 's', 'j', 'k', 'l', '1', '2', '3', '4'].includes(key)) {
                        e.preventDefault();
                        this.keys.add(key);
                    }
                });
                window.addEventListener('keyup', e => {
                    this.keys.delete(e.key.toLowerCase());
                });
            }

            update(deltaTime) {
                if(this.introFadeTimer > 0) this.introFadeTimer -= deltaTime;

                if (this.gameState !== 'playing') {
                     if (this.gameState === 'start') {
                         // 不更新
                    }
                    return;
                }
                
                this.spawnEnemies();
                this.player.update(this.keys, deltaTime);
            
                this.projectiles.forEach(p => p.update(deltaTime));
                this.projectiles = this.projectiles.filter(p => !p.markedForDeletion);

                this.companions.forEach(c => c.update(deltaTime));
                this.companions = this.companions.filter(c => !c.markedForDeletion);

                this.enemies.forEach(e => e.update(deltaTime));
                this.enemies = this.enemies.filter(e => !e.markedForDeletion);
                
                this.particles.forEach(p => p.update(deltaTime));
                this.particles = this.particles.filter(p => !p.markedForDeletion);
                
                this.items.forEach(i => i.update(deltaTime));
                this.items = this.items.filter(i => !i.markedForDeletion);
                
                this.effects.forEach(e => e.update(deltaTime));
                this.effects = this.effects.filter(e => !e.markedForDeletion);
                
                this.platforms.forEach(p => {
                    if(p.update) p.update(deltaTime);
                });
                this.platforms = this.platforms.filter(p => !p.markedForDeletion);

                this.floatingMessages.forEach(m => m.update(deltaTime));
                this.floatingMessages = this.floatingMessages.filter(m => !m.markedForDeletion);
                
                this.checkCollisions();
                this.checkLevelCompletion();
            }

            draw(context, deltaTime) {
                context.clearRect(0, 0, this.width, this.height);
                
                context.save();
                this.updateCamera(deltaTime); 
                context.scale(this.scale, this.scale); 
                context.translate(-this.camera.x, -this.camera.y);

                this.background.draw(context);
                this.platforms.forEach(p => p.draw(context));
                this.items.forEach(i => i.draw(context));
                if (this.gameState !== 'start') this.player.draw(context);
                this.companions.forEach(c => c.draw(context));
                this.projectiles.forEach(p => p.draw(context));
                this.enemies.forEach(e => e.draw(context));
                this.particles.forEach(p => p.draw(context));
                this.effects.forEach(e => e.draw(context));
                this.floatingMessages.forEach(m => m.draw(context));
                
                context.restore();

                this.ui.draw(context);

                if (this.gameState === 'start') {
                    this.drawStartScreen(context);
                } else if(this.introFadeTimer > 0) {
                    context.save();
                    context.fillStyle = `rgba(0,0,0,${this.introFadeTimer / 1000})`;
                    context.fillRect(0,0,this.width, this.height);
                    context.restore();
                }

                if(this.enemies.some(e => e instanceof MegaBoss && e.isWarning)){
                    const boss = this.enemies.find(e => e instanceof MegaBoss);
                    this.drawWarning(context, boss.warningType, boss.warningTimer);
                }

                if (this.gameOver) this.drawGameOverScreen(context, '遊戲結束');
                if (this.gameWon) this.drawGameOverScreen(context, '恭喜！培養基已淨化！');
                if (this.gameState === 'levelComplete') this.drawLevelCompleteScreen(context);
            }

            updateCamera(deltaTime) {
                const deadZoneLeft = this.camera.x + this.camera.deadZoneX;
                const deadZoneRight = this.camera.x + this.width / this.scale - this.camera.deadZoneX;

                if(this.player.x < deadZoneLeft) {
                    this.camera.x = this.player.x - this.camera.deadZoneX;
                } else if (this.player.x + this.player.width > deadZoneRight) {
                    this.camera.x = this.player.x + this.player.width - (this.width / this.scale - this.camera.deadZoneX);
                }

                if (this.camera.x < 0) this.camera.x = 0;
                if (this.camera.x > this.worldWidth - this.width / this.scale) {
                    this.camera.x = this.worldWidth - this.width / this.scale;
                }
                
                if (this.camera.shakeDuration > 0) {
                    this.camera.shakeDuration -= deltaTime;
                    this.camera.x += (Math.random() - 0.5) * this.camera.shakeMagnitude;
                    if(this.camera.shakeDuration <= 0) this.camera.shakeMagnitude = 0;
                }
            }
            
            drawStartScreen(context) {
                context.save();
                context.fillStyle = 'black';
                context.fillRect(0,0,this.width, this.height);
                context.textAlign = 'center';
                context.fillStyle = 'white';
                context.font = `${50 * this.scale}px "Microsoft JhengHei"`;
                context.fillText('杆菌之刃：孢子求生', this.width / 2, this.height * 0.4);

                context.save();
                const tempPlayerX = this.width / 2;
                const tempPlayerY = this.height * 0.5;
                context.translate(tempPlayerX, tempPlayerY);
                context.scale(this.scale * 1.5, this.scale * 1.5); // 放大顯示
                context.translate(-this.player.width/2, -this.player.height/2);
                this.player.draw(context);
                context.restore();
                
                context.font = `${20 * this.scale}px "Microsoft JhengHei"`;
                context.fillText('按 Enter 開始遊戲', this.width / 2, this.height * 0.7);
                context.restore();
            }
            drawGameOverScreen(context, message) {
                context.save();
                context.textAlign = 'center';
                context.fillStyle = 'rgba(0,0,0,0.7)';
                context.fillRect(0,0,this.width, this.height);
                context.fillStyle = 'white';
                context.font = `${40 * this.scale}px "Microsoft JhengHei"`;
                context.fillText(message, this.width / 2, this.height / 2 - 40 * this.scale);
                context.font = `${20 * this.scale}px "Microsoft JhengHei"`;
                context.fillText('按 Enter 重新開始', this.width / 2, this.height / 2);
                context.restore();
            }
            drawLevelCompleteScreen(context) {
                context.save();
                context.textAlign = 'center';
                context.fillStyle = 'rgba(0,0,0,0.5)';
                context.fillRect(0,0,this.width, this.height);
                context.fillStyle = 'white';
                context.font = `${40 * this.scale}px "Microsoft JhengHei"`;
                context.fillText(`第 ${this.level - 1} 關完成`, this.width / 2, this.height / 2 - 20 * this.scale);
                context.font = `${20 * this.scale}px "Microsoft JhengHei"`;
                context.fillText('準備進入下一關...', this.width / 2, this.height / 2 + 20 * this.scale);
                context.restore();
            }
            drawWarning(context, type, timer) {
                context.save();
                const text = type === 'shockwave' ? '衝擊波預備' : '全方位飛彈預備';
                const flash = Math.floor(timer / 500) % 2 === 0;

                context.globalAlpha = 0.5;
                context.strokeStyle = '#8e44ad';
                context.lineWidth = 20 * this.scale;
                context.strokeRect(0, 0, this.width, this.height);
                context.globalAlpha = 1.0;

                if (flash) {
                    context.textAlign = 'center';
                    context.fillStyle = '#ff0000';
                    context.font = `${60 * this.scale}px "Microsoft JhengHei"`;
                    context.shadowColor = 'black';
                    context.shadowBlur = 10;
                    context.fillText(text, this.width / 2, this.height / 2);
                }
                context.restore();
            }

            checkCollisions() {
                this.projectiles.forEach(p1 => {
                    if (p1.owner === 'player' && !p1.markedForDeletion) {
                        this.projectiles.forEach(p2 => {
                            if (p2.owner === 'enemy' && !p2.markedForDeletion) {
                                if (this.isColliding(p1, p2)) {
                                    p1.markedForDeletion = true;
                                    p2.markedForDeletion = true;
                                    this.createHitParticles(p1.x, p1.y, '#dda0dd');
                                }
                            }
                        });
                    }
                });

                this.projectiles.forEach(projectile => {
                    if (projectile.owner === 'player' && !projectile.markedForDeletion) {
                        this.enemies.forEach(enemy => {
                            if (this.isColliding(projectile, enemy)) {
                                enemy.takeDamage(projectile.damage, projectile.attackType);
                                projectile.markedForDeletion = true;
                                if(!(enemy instanceof Anthrax && (projectile.attackType === 'bow' || projectile.attackType === 'magic'))) {
                                    this.floatingMessages.push(new FloatingMessage(this, enemy.x + enemy.width / 2, enemy.y, String(projectile.damage), 'white'));
                                }
                                this.createHitParticles(projectile.x, projectile.y);
                            }
                        });
                    } 
                    else if (projectile.owner === 'enemy' && !projectile.markedForDeletion) {
                        if (this.isColliding(this.player, projectile) && !this.player.isStealth) {
                            this.player.takeDamage(projectile.damage);
                            projectile.markedForDeletion = true;
                        }
                    }
                });

                this.enemies.forEach(enemy => {
                    if (this.isColliding(this.player, enemy) && !this.player.isStealth) {
                        this.player.takeDamage(enemy.damage); 
                        enemy.takeDamage(enemy.damage, 'collision'); 
                    }
                });
                
                this.companions.forEach(companion => {
                    this.enemies.forEach(enemy => {
                        if (this.isColliding(companion, enemy)) {
                           enemy.takeDamage(companion.damage, 'companion');
                           companion.markedForDeletion = true; 
                           this.createHitParticles(companion.x, companion.y, '#00ff88');
                        }
                    });
                });
                
                this.items.forEach(item => {
                    if(this.isColliding(this.player, item)) {
                        item.applyEffect(this.player);
                        item.markedForDeletion = true;
                    }
                });
                
                this.effects.forEach(effect => {
                    if (effect.type === 'shockwave' && this.isColliding(this.player, effect)) {
                        this.player.takeDamage(effect.damage);
                        effect.markedForDeletion = true;
                    }
                });
            }
            
            isColliding(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            generatePlatforms() {
                this.platforms = [];
                const ground = new Platform(this, -100, this.height * 0.9, this.worldWidth + 200, this.height * 0.1);
                this.platforms.push(ground);

                if (this.level >= 2) {
                    const tierYPositions = [this.height * 0.75, this.height * 0.55, this.height * 0.35];
                    const minGap = 150;
                    const maxGap = 350;
                    const minPlatformWidth = 200;
                    const maxPlatformWidth = 500;
                    const platformCountMultiplier = 1 + this.level * 0.5;

                    tierYPositions.forEach(y => {
                        let currentX = 0;
                        while (currentX < this.worldWidth) {
                             const platformWidth = minPlatformWidth + Math.random() * (maxPlatformWidth - minPlatformWidth);
                            if (currentX + platformWidth < this.worldWidth) {
                                this.platforms.push(new Platform(this, currentX, y, platformWidth, 20));
                            }
                            currentX += platformWidth + (minGap + Math.random() * (maxGap - minGap));
                        }
                    });
                }
            }
            
            loadLevel() {
                if (this.level > this.levelData.length) {
                    this.gameWon = true;
                    return;
                }
                this.enemiesToSpawn = [];
                const currentLevel = this.levelData[this.level - 1];
                currentLevel.enemies.forEach(enemyInfo => {
                    for(let i = 0; i < enemyInfo.total; i++) {
                        this.enemiesToSpawn.push(enemyInfo.type);
                    }
                });
                this.enemiesToSpawn.sort(() => Math.random() - 0.5);
                this.generatePlatforms();
                this.background.updateLevel();
            }
            
            setPlayerInitialPosition() {
                 const spawnablePlatforms = this.platforms.filter(p => p.y < this.height * 0.9);
                if (spawnablePlatforms.length > 0) {
                    const spawnPlatform = spawnablePlatforms[Math.floor(Math.random() * spawnablePlatforms.length)];
                    this.player.x = spawnPlatform.x + spawnPlatform.width / 2;
                    this.player.y = spawnPlatform.y - this.player.height;
                } else {
                    this.player.x = 200;
                    this.player.y = this.height * 0.9 - this.player.height;
                }
                 this.player.vy = 0;
            }
            
            spawnEnemies() {
                const currentLevel = this.levelData[this.level - 1];
                if (this.enemies.length < currentLevel.maxOnScreen && this.enemiesToSpawn.length > 0) {
                    const enemyType = this.enemiesToSpawn.pop();
                    
                    const spawnPlatforms = this.platforms.filter(p => p.y < this.height * 0.9);
                    const spawnPlatform = spawnPlatforms.length > 0 ? spawnPlatforms[Math.floor(Math.random() * spawnPlatforms.length)] : this.platforms[0];
                    const spawnX = spawnPlatform.x + Math.random() * spawnPlatform.width;

                    if (enemyType === 'Yeast') {
                        this.enemies.push(new Yeast(this, spawnX, spawnPlatform.y - 60, spawnPlatform));
                    } else if (enemyType === 'Anthrax') {
                         this.enemies.push(new Anthrax(this, spawnX, spawnPlatform.y - 40, spawnPlatform));
                    } else if (enemyType === 'Phytophthora') {
                        this.enemies.push(new Phytophthora(this));
                    } else if (enemyType === 'MegaBoss') {
                        this.enemies.push(new MegaBoss(this));
                    }
                }
            }
            
            checkLevelCompletion() {
                if (this.enemies.length === 0 && this.enemiesToSpawn.length === 0 && this.gameState === 'playing' && !this.gameWon) {
                    this.gameState = 'levelComplete';
                    this.player.heal(this.player.maxHealth * 0.4);
                    this.floatingMessages.push(new FloatingMessage(this, this.player.x, this.player.y, `關卡恢復! +${Math.round(this.player.maxHealth * 0.4)}HP`, '#2ecc71'));
                    
                    this.level++;
                    setTimeout(() => {
                        if(!this.gameWon) {
                           this.loadLevel();
                           this.setPlayerInitialPosition(); 
                           this.gameState = 'playing';
                        }
                    }, 3000);
                }
            }

            restartGame() {
                this.level = 1;
                this.gameOver = false;
                this.gameWon = false;
                this.loadLevel();
                this.player = new Player(this);
                this.setPlayerInitialPosition();
                this.projectiles = [];
                this.companions = [];
                this.enemies = [];
                this.particles = [];
                this.items = [];
                this.effects = [];
                this.floatingMessages = [];
                this.gameState = 'playing';
            }
            
            createHitParticles(x, y, color = 'white') {
                for (let i = 0; i < 5; i++) {
                    this.particles.push(new Particle(this, x, y, color));
                }
            }
        }
        
        // 主遊戲循環
        let game;
        let lastTime = 0;

        function animate(timestamp) {
            const deltaTime = (timestamp - lastTime) || 0;
            lastTime = timestamp;
            if (game) {
                game.update(deltaTime);
                game.draw(ctx, deltaTime);
            }
            requestAnimationFrame(animate);
        }
        
        // 窗口加載和大小調整事件
        window.addEventListener('load', () => {
            resizeCanvas();
            game = new Game(canvas.width, canvas.height, scale);
            animate(0);
        });

        window.addEventListener('resize', () => {
             resizeCanvas();
        });
    </script>
</body>
</html>
